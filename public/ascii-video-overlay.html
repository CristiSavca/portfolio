<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ASCII Video Overlay</title>
  <style>
    @font-face {
      font-family: 'Geist Pixel Square';
      src: url('/fonts/GeistPixel-Square.woff2') format('woff2');
      font-weight: normal;
      font-style: normal;
    }
    @font-face {
      font-family: 'Geist Pixel Grid';
      src: url('/fonts/GeistPixel-Grid.woff2') format('woff2');
      font-weight: normal;
      font-style: normal;
    }
    @font-face {
      font-family: 'Geist Pixel Circle';
      src: url('/fonts/GeistPixel-Circle.woff2') format('woff2');
      font-weight: normal;
      font-style: normal;
    }
    @font-face {
      font-family: 'Geist Pixel Triangle';
      src: url('/fonts/GeistPixel-Triangle.woff2') format('woff2');
      font-weight: normal;
      font-style: normal;
    }
    @font-face {
      font-family: 'Geist Pixel Line';
      src: url('/fonts/GeistPixel-Line.woff2') format('woff2');
      font-weight: normal;
      font-style: normal;
    }
    :root {
      --font-geist-pixel-square: "Geist Pixel Square", monospace;
      --font-geist-pixel-grid: "Geist Pixel Grid", monospace;
      --font-geist-pixel-circle: "Geist Pixel Circle", monospace;
      --font-geist-pixel-triangle: "Geist Pixel Triangle", monospace;
      --font-geist-pixel-line: "Geist Pixel Line", monospace;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: system-ui, sans-serif;
      background: #0a0a0a;
      color: #e5e5e5;
      min-height: 100vh;
      padding: 0.5rem;
    }
    .container { max-width: 1400px; margin: 0 auto; }
    h1 { font-size: 1rem; margin-bottom: 0.5rem; font-weight: 500; }
    .main {
      display: grid;
      grid-template-columns: minmax(320px, 380px) 1fr;
      gap: 0.75rem;
    }
    @media (max-width: 900px) {
      .main { grid-template-columns: 1fr; }
    }
    .controls {
      background: #141414;
      border: 1px solid #262626;
      border-radius: 6px;
      padding: 0.6rem;
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      font-size: 0.75rem;
      overflow-y: auto;
      overflow-x: hidden;
      min-width: 0;
      max-height: calc(100vh - 2rem);
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 0.15rem;
    }
    .control-hint { font-size: 0.6rem; color: #525252; margin-top: 0.2rem; display: block; }
    .control-group label {
      font-size: 0.65rem;
      color: #737373;
      text-transform: uppercase;
      letter-spacing: 0.03em;
    }
    .control-group input, .control-group select, .control-group textarea {
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 3px;
      color: #fff;
      padding: 0.25rem 0.35rem;
      font-size: 0.75rem;
      min-width: 0;
      width: 100%;
    }
    .control-group textarea { min-height: 36px; resize: vertical; font-family: monospace; }
    .control-group input[type="color"] {
      height: 24px;
      padding: 1px;
      cursor: pointer;
    }
    .control-group input[type="range"] {
      accent-color: #fff;
    }
    .preview-area {
      position: relative;
      background: #000;
      border-radius: 6px;
      overflow: hidden;
      aspect-ratio: 16/9;
      min-height: 0;
    }
    .preview-area .media-frame {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .preview-area .media-frame video {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: contain;
      object-position: center;
    }
    .preview-area.transform-mode .media-frame video.hidden {
      width: 0; height: 0;
      opacity: 0;
      pointer-events: none;
    }
    .ascii-viewport {
      position: absolute;
      overflow: hidden;
      pointer-events: none;
      box-sizing: border-box;
    }
    .ascii-viewport.transform-mode {
      inset: 0;
      width: 100%;
      height: 100%;
    }
    .preview-area.transform-mode .ascii-viewport {
      background: #000;
    }
    .ascii-viewport canvas {
      display: block;
      width: 100%;
      height: 100%;
    }
    #waveCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      display: none;
    }
    body.embed-mode #waveCanvas {
      display: block;
    }
    .ascii-viewport pre {
      display: none;
    }
    .drop-zone {
      border: 2px dashed #404040;
      border-radius: 4px;
      padding: 0.75rem 0.5rem;
      text-align: center;
      color: #737373;
      cursor: pointer;
      font-size: 0.7rem;
      transition: border-color 0.2s, color 0.2s;
    }
    .drop-zone:hover, .drop-zone.dragover {
      border-color: #525252;
      color: #a3a3a3;
    }
    .drop-zone input { display: none; }
    .char-presets {
      display: flex;
      flex-wrap: wrap;
      gap: 0.2rem;
      margin-top: 0.25rem;
    }
    .char-preset {
      padding: 0.15rem 0.35rem;
      background: #1a1a1a;
      border: 1px solid #333;
      border-radius: 3px;
      font-size: 0.65rem;
      cursor: pointer;
      font-family: monospace;
    }
    .btn {
      background: #262626;
      border: 1px solid #404040;
      border-radius: 4px;
      color: #fff;
      padding: 0.35rem 0.6rem;
      font-size: 0.75rem;
      cursor: pointer;
    }
    .btn:hover { background: #333; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .char-preset:hover { background: #262626; }
    .char-preset.active { background: #333; border-color: #525252; }

    body.embed-mode {
      padding: 0;
      overflow: hidden;
      background: #000;
    }
    body.embed-mode .container {
      max-width: none;
      width: 100vw;
      height: 100vh;
      margin: 0;
    }
    body.embed-mode h1,
    body.embed-mode .controls {
      display: none;
    }
    body.embed-mode .main {
      display: block;
      width: 100%;
      height: 100%;
      gap: 0;
    }
    body.embed-mode .preview-area {
      width: 100%;
      height: 100%;
      border-radius: 0;
      aspect-ratio: auto;
      background: #000;
    }
    body.embed-mode .preview-area .media-frame {
      inset: 0;
      width: 100%;
      height: 100%;
      left: 0;
      top: 0;
      right: auto;
      bottom: auto;
      transform: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ASCII Video Overlay</h1>
    <div class="main">
      <aside class="controls">
        <div class="control-group">
          <label>Mode</label>
          <select id="mode">
            <option value="overlay">Overlay (ASCII on video)</option>
            <option value="transform" selected>Transform (ASCII only)</option>
          </select>
        </div>
        <div class="control-group">
          <label>Playback Speed</label>
          <input type="range" id="speed" min="0.1" max="4" value="0.1" step="0.05">
          <span id="speedVal">0.1x</span>
        </div>
        <div class="control-group wide">
          <label>Video Source</label>
          <div class="drop-zone" id="dropZone">
            <input type="file" id="videoInput" accept="video/*">
            <span id="dropLabel">Drop or click</span>
          </div>
          <input type="text" id="videoUrl" placeholder="Or paste URL + Enter">
        </div>
        <div class="control-group">
          <label>Font</label>
          <select id="fontSelect">
            <option value="var(--font-geist-pixel-square)">Geist Pixel Square</option>
            <option value="var(--font-geist-pixel-grid)">Geist Pixel Grid</option>
            <option value="var(--font-geist-pixel-circle)">Geist Pixel Circle</option>
            <option value="var(--font-geist-pixel-triangle)">Geist Pixel Triangle</option>
            <option value="var(--font-geist-pixel-line)">Geist Pixel Line</option>
            <option value="monospace" selected>System Monospace</option>
            <option value="'Courier New', monospace">Courier New</option>
          </select>
        </div>
        <div class="control-group">
          <label>Color Mode</label>
          <select id="colorMode">
            <option value="mono" selected>Single color</option>
            <option value="rgb">Per-pixel (video colors)</option>
          </select>
        </div>
        <div class="control-group" id="colorPickerGroup">
          <label>Color</label>
          <input type="color" id="colorPicker" value="#00ff00">
        </div>
        <div class="control-group">
          <label>Map Mode</label>
          <select id="mapMode">
            <option value="brightness">Brightness</option>
            <option value="inverted" selected>Inverted</option>
            <option value="edges">Edges</option>
            <option value="combined">Brightness + Edges</option>
            <option value="highcontrast">High contrast</option>
          </select>
        </div>
        <div class="control-group">
          <label>Contrast (gamma)</label>
          <input type="range" id="contrast" min="10" max="200" value="50" step="5">
          <span id="contrastVal">50%</span>
        </div>
        <div class="control-group">
          <label>Characters (darkâ†’bright)</label>
          <input type="text" id="customChars" value="@#W$9876543210?!abc;:+=-,._ " readonly>
          <div class="char-presets">
            <button class="char-preset active" data-chars="@#W$9876543210?!abc;:+=-,._ ">Classic</button>
          </div>
        </div>
        <div class="control-group">
          <label>Quality</label>
          <input type="range" id="quality" min="25" max="300" value="240" step="5">
          <span id="qualityVal">240%</span>
        </div>
        <div class="control-group">
          <label>Density (chars)</label>
          <input type="range" id="density" min="25" max="200" value="100" step="5">
          <span id="densityVal">100%</span>
        </div>
        <div class="control-group">
          <label>Font size</label>
          <input type="range" id="fontSize" min="50" max="150" value="140" step="5">
          <span id="fontSizeVal">140%</span>
        </div>
        <div class="control-group">
          <label>Resolution (render scale)</label>
          <input type="range" id="resolution" min="1" max="4" value="4" step="1">
          <span id="resolutionVal">4x</span>
        </div>
        <div class="control-group">
          <label>Depth (brightness modulation)</label>
          <input type="range" id="depth" min="0" max="100" value="95" step="5">
          <span id="depthVal">95%</span>
        </div>
        <div class="control-group">
          <label>Smoothness (frame blend)</label>
          <input type="range" id="smoothness" min="0" max="95" value="0" step="5">
          <span id="smoothnessVal">0%</span>
        </div>
        <div class="control-group">
          <button class="btn" id="recordBtn">Download MP4</button>
          <button class="btn" id="exportReactBtn" style="margin-top: 0.5rem;">Export React Component</button>
          <span class="control-hint">MP4: ~2 min/1 min video. React: saves your preset + same real-time pipeline; pass videoSrc URL.</span>
        </div>
      </aside>
      <div class="preview-area" id="previewArea">
        <div class="media-frame" id="mediaFrame">
          <video id="video" muted loop playsinline autoplay webkit-playsinline preload="auto"></video>
          <div class="ascii-viewport" id="asciiViewport">
            <canvas id="asciiCanvas"></canvas>
            <pre id="asciiOutput"></pre>
          </div>
          <canvas id="waveCanvas"></canvas>
        </div>
      </div>
    </div>
  </div>
  <script>
    const searchParams = new URLSearchParams(window.location.search);
    const embedMode = searchParams.get('embed') === '1';
    const embedVideo = searchParams.get('video') || '';
    let colorChannel = (searchParams.get('channel') || 'rgb').toLowerCase();
    if (!['rgb', 'r', 'g', 'b'].includes(colorChannel)) colorChannel = 'rgb';

    if (embedMode) document.body.classList.add('embed-mode');

    const ENABLE_EMBED_WAVE = true;
    const video = document.getElementById('video');
    const asciiOutput = document.getElementById('asciiOutput');
    const dropZone = document.getElementById('dropZone');
    const videoInput = document.getElementById('videoInput');
    const ctx = document.createElement('canvas').getContext('2d', { willReadFrequently: true });

    const CLASSIC_CHARSET = "@#W$9876543210?!abc;:+=-,._~^*|/<>[]{}()";
    let chars = CLASSIC_CHARSET;
    let rafId = null;
    let lastFrameData = null;
    let prevFrameData = null;
    let hasSentFrameSignal = false;
    const recordCanvas = document.createElement('canvas');
    const recordCtx = recordCanvas.getContext('2d', { willReadFrequently: true });
    recordCtx.imageSmoothingEnabled = false;

    const presets = {
      'Geist Pixel Square': 'var(--font-geist-pixel-square)',
      'Geist Pixel Grid': 'var(--font-geist-pixel-grid)',
      'Geist Pixel Circle': 'var(--font-geist-pixel-circle)',
      'Geist Pixel Triangle': 'var(--font-geist-pixel-triangle)',
      'Geist Pixel Line': 'var(--font-geist-pixel-line)',
      'System Monospace': 'monospace',
      'Courier New': "'Courier New', monospace",
    };

    function requestVideoPlayback() {
      video.muted = true;
      video.defaultMuted = true;
      video.loop = true;
      video.autoplay = true;
      video.playsInline = true;
      video.setAttribute('muted', '');
      video.setAttribute('autoplay', '');
      video.setAttribute('playsinline', '');
      video.setAttribute('webkit-playsinline', '');
      if (video.src && video.networkState === 0) video.load();
      const playResult = video.play();
      if (playResult && typeof playResult.catch === 'function') {
        playResult.catch(() => {
          const resume = () => {
            video.play().catch(() => {});
          };
          window.addEventListener('touchstart', resume, { once: true, passive: true });
          window.addEventListener('pointerdown', resume, { once: true, passive: true });
          window.addEventListener('click', resume, { once: true });
        });
      }
    }

    dropZone.onclick = () => videoInput.click();
    dropZone.ondragover = (e) => { e.preventDefault(); dropZone.classList.add('dragover'); };
    dropZone.ondragleave = () => dropZone.classList.remove('dragover');
    dropZone.ondrop = (e) => {
      e.preventDefault();
      dropZone.classList.remove('dragover');
      const file = e.dataTransfer.files[0];
      if (file?.type.startsWith('video/')) loadVideo(file);
    };
    videoInput.onchange = () => {
      const file = videoInput.files[0];
      if (file) loadVideo(file);
    };

    function resetInterpolationState() {
      lastFrameData = null;
      prevFrameData = null;
      hasSentFrameSignal = false;
    }

    document.getElementById('videoUrl').onkeydown = (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        const url = document.getElementById('videoUrl').value.trim();
        if (url) {
          resetInterpolationState();
          video.src = url;
          video.load();
          video.onloadeddata = () => requestVideoPlayback();
        }
      }
    };

    function loadVideo(file) {
      const url = URL.createObjectURL(file);
      resetInterpolationState();
      video.src = url;
      video.load();
      video.onloadeddata = () => {
        document.getElementById('dropLabel').textContent = file.name;
        requestVideoPlayback();
      };
    }

    const customCharsEl = document.getElementById('customChars');
    customCharsEl.value = CLASSIC_CHARSET;
    customCharsEl.readOnly = true;
    document.querySelectorAll('.char-preset').forEach(btn => {
      btn.onclick = () => {
        chars = CLASSIC_CHARSET;
        customCharsEl.value = CLASSIC_CHARSET;
        document.querySelectorAll('.char-preset').forEach(b => b.classList.toggle('active', b === btn));
      };
    });

    document.getElementById('fontSelect').onchange = (e) => {
      asciiOutput.style.fontFamily = e.target.options[e.target.selectedIndex].value;
    };

    document.getElementById('colorPicker').oninput = (e) => {
      asciiOutput.style.color = e.target.value;
    };

    document.getElementById('colorMode').onchange = (e) => {
      document.getElementById('colorPickerGroup').style.display =
        e.target.value === 'mono' ? 'block' : 'none';
    };

    document.getElementById('quality').oninput = (e) => {
      document.getElementById('qualityVal').textContent = e.target.value + '%';
    };

    document.getElementById('resolution').oninput = (e) => {
      document.getElementById('resolutionVal').textContent = e.target.value + 'x';
      drawToOverlayCanvas();
    };

    document.getElementById('speed').oninput = (e) => {
      const v = parseFloat(e.target.value);
      video.playbackRate = v;
      document.getElementById('speedVal').textContent = (v < 1 ? v : Math.round(v * 10) / 10) + 'x';
    };

    document.getElementById('depth').oninput = (e) => {
      document.getElementById('depthVal').textContent = e.target.value + '%';
      drawToOverlayCanvas();
    };

    document.getElementById('contrast').oninput = (e) => {
      document.getElementById('contrastVal').textContent = e.target.value + '%';
    };

    document.getElementById('density').oninput = (e) => {
      document.getElementById('densityVal').textContent = e.target.value + '%';
      drawToOverlayCanvas();
    };

    document.getElementById('fontSize').oninput = (e) => {
      document.getElementById('fontSizeVal').textContent = e.target.value + '%';
      drawToOverlayCanvas();
    };

    document.getElementById('smoothness').oninput = (e) => {
      document.getElementById('smoothnessVal').textContent = e.target.value + '%';
    };

    document.getElementById('mode').onchange = (e) => {
      const isTransform = e.target.value === 'transform';
      video.classList.toggle('hidden', isTransform);
      document.getElementById('previewArea').classList.toggle('transform-mode', isTransform);
      drawToOverlayCanvas();
    };

    function setControlValue(id, value, eventType = 'input') {
      const el = document.getElementById(id);
      if (!el) return;
      el.value = String(value);
      el.dispatchEvent(new Event(eventType, { bubbles: true }));
    }

    function applyEmbedPreset() {
      setControlValue('mode', 'transform', 'change');
      setControlValue('speed', '0.1');
      setControlValue('fontSelect', 'monospace', 'change');
      setControlValue('colorMode', 'rgb', 'change');
      setControlValue('mapMode', 'inverted', 'change');
      setControlValue('contrast', '50');
      setControlValue('customChars', CLASSIC_CHARSET);
      setControlValue('quality', '300');
      setControlValue('density', '180');
      setControlValue('fontSize', '150');
      setControlValue('resolution', '4');
      setControlValue('depth', '95');
      setControlValue('smoothness', '0');
      video.playbackRate = 0.1;
      const source = embedVideo || '/assets/1VS0Hpe2Ses6lS-U.mp4';
      if (source) {
        resetInterpolationState();
        video.src = source;
        video.load();
        video.onloadeddata = () => {
          video.playbackRate = 0.1;
          requestVideoPlayback();
        };
      }
      window.parent?.postMessage({ type: 'ascii-ready' }, '*');
    }

    window.addEventListener('message', (event) => {
      const data = event.data;
      if (!data || typeof data !== 'object') return;
      if (data.type === 'ascii:setColorChannel') {
        const next = String(data.channel || 'rgb').toLowerCase();
        colorChannel = ['rgb', 'r', 'g', 'b'].includes(next) ? next : 'rgb';
        setControlValue('colorMode', 'rgb', 'change');
      }
      if (data.type === 'ascii:resume') requestVideoPlayback();
      if (data.type === 'ascii:refresh') drawToOverlayCanvas();
    });

    asciiOutput.style.fontFamily = document.getElementById('fontSelect').value;
    asciiOutput.style.color = '#00ff00';
    if (embedMode) applyEmbedPreset();

    const asciiViewport = document.getElementById('asciiViewport');
    const asciiCanvas = document.getElementById('asciiCanvas');
    const waveCanvas = document.getElementById('waveCanvas');
    const previewArea = document.getElementById('previewArea');
    const waveCtx = waveCanvas ? waveCanvas.getContext('2d') : null;

    let fixedCols = 0, fixedRows = 0;
    const measureCtx = document.createElement('canvas').getContext('2d');

    function measureChar(font, char) {
      measureCtx.font = font;
      const m = measureCtx.measureText(char);
      const fontSize = parseInt(font) || 16;
      const height = (m.actualBoundingBoxAscent != null && m.actualBoundingBoxDescent != null)
        ? m.actualBoundingBoxAscent + m.actualBoundingBoxDescent
        : fontSize;
      return { width: m.width, height };
    }

    function drawToRecordCanvas() {
      if (!lastFrameData || !recordCtx) return;
      const { cols, rows, cells, colorMode } = lastFrameData;
      const isOverlay = document.getElementById('mode').value === 'overlay';
      recordCtx.fillStyle = '#000';
      recordCtx.fillRect(0, 0, recordCanvas.width, recordCanvas.height);
      if (isOverlay && video.readyState >= 2) {
        recordCtx.drawImage(video, 0, 0, recordCanvas.width, recordCanvas.height);
      }
      const baseCellH = recordCanvas.height / Math.max(1, rows);
      const baseFontSize = Math.max(4, Math.min(96, Math.floor(baseCellH * 0.94)));
      const fontSizeScale = parseInt(document.getElementById('fontSize').value) || 100;
      const fontSize = Math.max(4, Math.min(96, Math.round(baseFontSize * fontSizeScale / 100)));
      const fontFamily = getComputedStyle(asciiOutput).fontFamily;
      recordCtx.font = `${fontSize}px ${fontFamily}`;
      recordCtx.textAlign = 'center';
      recordCtx.textBaseline = 'middle';
      const cellW = recordCanvas.width / cols;
      const cellH = recordCanvas.height / rows;
      let i = 0;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = cells[i++];
          if (!cell) break;
          recordCtx.fillStyle = `rgb(${cell.r},${cell.g},${cell.b})`;
          recordCtx.fillText(cell.ch, (c + 0.5) * cellW, (r + 0.5) * cellH);
        }
      }
    }

    function drawToOverlayCanvas() {
      if (!lastFrameData) return;
      const { cols, rows, cells } = lastFrameData;
      const mediaFrame = document.getElementById('mediaFrame');
      const frameRect = mediaFrame.getBoundingClientRect();
      const w = video.videoWidth;
      const h = video.videoHeight;
      const isOverlay = document.getElementById('mode').value === 'overlay';
      let targetW, targetH, vpLeft = 0, vpTop = 0;
      if (w && h) {
        const s = embedMode
          ? Math.max(frameRect.width / w, frameRect.height / h)
          : Math.min(frameRect.width / w, frameRect.height / h);
        targetW = w * s;
        targetH = h * s;
        vpLeft = (frameRect.width - targetW) / 2;
        vpTop = (frameRect.height - targetH) / 2;
        asciiViewport.classList.remove('transform-mode');
        asciiViewport.style.left = vpLeft + 'px';
        asciiViewport.style.top = vpTop + 'px';
        asciiViewport.style.width = targetW + 'px';
        asciiViewport.style.height = targetH + 'px';
      } else {
        targetW = frameRect.width;
        targetH = frameRect.height;
        asciiViewport.classList.add('transform-mode');
        asciiViewport.style.left = '';
        asciiViewport.style.top = '';
        asciiViewport.style.width = '';
        asciiViewport.style.height = '';
      }
      const scale = parseInt(document.getElementById('resolution').value) || 2;
      const renderW = Math.max(1, Math.floor(targetW * scale));
      const renderH = Math.max(1, Math.floor(targetH * scale));
      const ctx = asciiCanvas.getContext('2d');
      asciiCanvas.width = renderW;
      asciiCanvas.height = renderH;
      asciiCanvas.style.width = targetW + 'px';
      asciiCanvas.style.height = targetH + 'px';
      ctx.imageSmoothingEnabled = false;
      const cellW = renderW / cols;
      const cellH = renderH / rows;
      const baseCellH = renderH / Math.max(1, rows);
      const baseFontSize = Math.max(4, Math.min(96, Math.floor(baseCellH * 0.94)));
      const fontSizeScale = parseInt(document.getElementById('fontSize').value) || 100;
      const fontSize = Math.max(4, Math.min(96, Math.round(baseFontSize * fontSizeScale / 100)));
      const fontFamily = getComputedStyle(asciiOutput).fontFamily;
      ctx.font = `${fontSize}px ${fontFamily}`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.clearRect(0, 0, renderW, renderH);
      if (isOverlay && video.readyState >= 2) {
        ctx.drawImage(video, 0, 0, renderW, renderH);
      } else {
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, renderW, renderH);
      }
      let i = 0;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const cell = cells[i++];
          if (!cell) break;
          ctx.fillStyle = `rgb(${cell.r},${cell.g},${cell.b})`;
          ctx.fillText(cell.ch, (c + 0.5) * cellW, (r + 0.5) * cellH);
        }
      }

      if (ENABLE_EMBED_WAVE && embedMode) {
        drawWaveEdges({
          cols,
          rows,
          cells,
          frameRect,
          vpLeft,
          vpTop,
          targetW,
          targetH,
          fontFamily,
          fontSize,
          resolutionScale: scale,
        });
      } else if (waveCtx && waveCanvas) {
        if (waveCanvas.width !== Math.max(1, Math.floor(frameRect.width)) || waveCanvas.height !== Math.max(1, Math.floor(frameRect.height))) {
          waveCanvas.width = Math.max(1, Math.floor(frameRect.width));
          waveCanvas.height = Math.max(1, Math.floor(frameRect.height));
        }
        waveCtx.clearRect(0, 0, waveCanvas.width, waveCanvas.height);
      }
    }

    function drawWaveEdges({
      cols,
      rows,
      cells,
      frameRect,
      vpLeft,
      vpTop,
      targetW,
      targetH,
      fontFamily,
      fontSize,
      resolutionScale,
    }) {
      if (!ENABLE_EMBED_WAVE) return;
      if (!waveCtx || !waveCanvas) return;

      const w = Math.max(1, Math.floor(frameRect.width));
      const h = Math.max(1, Math.floor(frameRect.height));
      if (waveCanvas.width !== w || waveCanvas.height !== h) {
        waveCanvas.width = w;
        waveCanvas.height = h;
      }
      waveCanvas.style.width = `${frameRect.width}px`;
      waveCanvas.style.height = `${frameRect.height}px`;
      waveCtx.clearRect(0, 0, w, h);

      if (!embedMode) return;

      const cellW = targetW / cols;
      const cellH = targetH / rows;
      const leftSeamX = vpLeft + cellW * 0.5;
      const rightStart = vpLeft + targetW;
      const rightSeamX = rightStart - cellW * 0.5;
      const leftWidth = Math.max(0, leftSeamX);
      const rightWidth = Math.max(0, frameRect.width - rightSeamX);
      if (leftWidth <= 0 && rightWidth <= 0) return;

      const waveFontSize = Math.max(4, Math.round(fontSize / Math.max(1, resolutionScale)));
      waveCtx.font = `${waveFontSize}px ${fontFamily}`;
      waveCtx.textAlign = 'center';
      waveCtx.textBaseline = 'middle';

      const rowStride = 1;
      const sourceBand = Math.max(2, Math.min(8, cols));
      const tNow = performance.now() * 0.0052;

      const drawSide = (side) => {
        const isLeft = side === 'left';
        const maxReach = isLeft ? leftWidth : rightWidth;
        if (maxReach <= 0) return;
        const seamX = isLeft ? leftSeamX : rightSeamX;
        const direction = isLeft ? -1 : 1;

        for (let r = 0; r < rows; r++) {
          const seamCell = isLeft ? cells[r * cols] : cells[r * cols + (cols - 1)];
          const y = vpTop + (r + 0.5) * cellH;
          waveCtx.fillStyle = `rgba(${seamCell.r},${seamCell.g},${seamCell.b},1)`;
          waveCtx.fillText(seamCell.ch, seamX, y);

          // Keep the wave flush at the seam with no dim buffer.
          for (let k = 1; k <= 4; k++) {
            const srcCol = isLeft ? Math.min(k - 1, cols - 1) : Math.max(cols - k, 0);
            const srcCell = cells[r * cols + srcCol] || seamCell;
            const a = Math.max(0.86, 1 - k * 0.03);
            const x = seamX + direction * k * cellW * 0.36;
            waveCtx.fillStyle = `rgba(${srcCell.r},${srcCell.g},${srcCell.b},${a})`;
            waveCtx.fillText(srcCell.ch, x, y);
          }
        }

        for (let r = 0; r < rows; r += rowStride) {
          const edgeCell = isLeft ? cells[r * cols] : cells[r * cols + (cols - 1)];
          const edgeLum = luminance(edgeCell.r, edgeCell.g, edgeCell.b);
          const reach = maxReach * Math.min(1.9, 0.72 + Math.pow(edgeLum, 0.65) * 1.4);
          const steps = Math.max(4, Math.floor(reach / Math.max(2, cellW * 1.1)));
          const yBase = vpTop + (r + 0.5) * cellH;

          const bridgeSteps = Math.min(8, steps);
          for (let b = 0; b < bridgeSteps; b++) {
            const xBridge = seamX + direction * b * cellW * 0.42;
            const aBridge = Math.max(0.9, 1 - b * 0.045);
            waveCtx.fillStyle = `rgba(${edgeCell.r},${edgeCell.g},${edgeCell.b},${aBridge})`;
            waveCtx.fillText(edgeCell.ch, xBridge, yBase);
          }

          for (let s = 0; s < steps; s++) {
            const t = s / steps;
            const fade = Math.max(0, Math.pow(1 - t, 0.46));
            if (fade < 0.01) continue;
            const band = Math.min(sourceBand - 1, Math.floor(t * sourceBand * 1.8));
            const srcCol = isLeft ? band : cols - 1 - band;
            const srcCell = cells[r * cols + srcCol] || edgeCell;
            const phase = tNow + r * 0.14 + s * 0.33;
            const jitterRamp = 0.2 + 0.8 * t;
            const xJitter = Math.sin(phase) * (cellW * 0.28) * jitterRamp;
            const yJitter = Math.cos(phase * 0.9) * (cellH * 0.16) * jitterRamp;
            const x = seamX + direction * t * reach + xJitter;
            const y = yBase + yJitter;
            const alpha = Math.min(1, 0.55 + fade * 0.6);
            waveCtx.fillStyle = `rgba(${srcCell.r},${srcCell.g},${srcCell.b},${alpha})`;
            waveCtx.fillText(srcCell.ch, x, y);
          }
        }
      };

      drawSide('left');
      drawSide('right');
    }

    function luminance(R, G, B) {
      return (0.299 * R + 0.587 * G + 0.114 * B) / 255;
    }

    function hexToRgb(hex) {
      const m = hex.match(/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i);
      return m ? { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) } : { r: 0, g: 255, b: 0 };
    }

    function applyDepth(baseRgb, lum, depthPct) {
      if (depthPct === 0) return { r: baseRgb.r, g: baseRgb.g, b: baseRgb.b };
      const t = depthPct / 100;
      const brightness = 0.04 + 0.96 * lum;
      const mixed = 1 - t + t * brightness;
      return { r: Math.round(baseRgb.r * mixed), g: Math.round(baseRgb.g * mixed), b: Math.round(baseRgb.b * mixed) };
    }

    function lerpCell(prev, curr, blend) {
      if (!prev || prev.r === undefined) return curr;
      curr.r = Math.round((prev.r || 0) * blend + (curr.r || 0) * (1 - blend));
      curr.g = Math.round((prev.g || 0) * blend + (curr.g || 0) * (1 - blend));
      curr.b = Math.round((prev.b || 0) * blend + (curr.b || 0) * (1 - blend));
      return curr;
    }

    function sampleBrightness(data, w, h, px, py) {
      const i = (Math.min(py, h - 1) * w + Math.min(px, w - 1)) * 4;
      return luminance(data[i], data[i + 1], data[i + 2]);
    }

    function sampleCellBrightness(data, w, h, x0, y0, x1, y1) {
      let sum = 0, count = 0;
      const xStart = Math.max(0, Math.floor(x0)), xEnd = Math.min(w, Math.ceil(x1));
      const yStart = Math.max(0, Math.floor(y0)), yEnd = Math.min(h, Math.ceil(y1));
      for (let py = yStart; py < yEnd; py++) {
        for (let px = xStart; px < xEnd; px++) {
          const i = (py * w + px) * 4;
          sum += luminance(data[i], data[i + 1], data[i + 2]);
          count++;
        }
      }
      return count > 0 ? sum / count : 0;
    }

    function sampleCellRgb(data, w, h, x0, y0, x1, y1) {
      let r = 0, g = 0, b = 0, count = 0;
      const xStart = Math.max(0, Math.floor(x0)), xEnd = Math.min(w, Math.ceil(x1));
      const yStart = Math.max(0, Math.floor(y0)), yEnd = Math.min(h, Math.ceil(y1));
      for (let py = yStart; py < yEnd; py++) {
        for (let px = xStart; px < xEnd; px++) {
          const i = (py * w + px) * 4;
          r += data[i]; g += data[i + 1]; b += data[i + 2];
          count++;
        }
      }
      if (count === 0) return { r: 0, g: 0, b: 0, lum: 0 };
      return { r: r / count, g: g / count, b: b / count, lum: luminance(r / count, g / count, b / count) };
    }

    function sampleEdge(data, w, h, px, py) {
      const g = (x, y) => sampleBrightness(data, w, h, x, y);
      const gx = (-g(px - 1, py - 1) - 2 * g(px - 1, py) - g(px - 1, py + 1) +
        g(px + 1, py - 1) + 2 * g(px + 1, py) + g(px + 1, py + 1)) / 4;
      const gy = (-g(px - 1, py - 1) - 2 * g(px, py - 1) - g(px + 1, py - 1) +
        g(px - 1, py + 1) + 2 * g(px, py + 1) + g(px + 1, py + 1)) / 4;
      return Math.min(1, Math.sqrt(gx * gx + gy * gy) * 3);
    }

    function applyContrast(val, contrastPct) {
      if (contrastPct === 100) return val;
      const gamma = contrastPct / 100;
      return Math.pow(Math.max(0, Math.min(1, val)), 1 / gamma);
    }

    function getValue(data, w, h, px, py, mapMode) {
      if (mapMode === 'brightness') return sampleBrightness(data, w, h, px, py);
      if (mapMode === 'inverted') return 1 - sampleBrightness(data, w, h, px, py);
      if (mapMode === 'edges') return sampleEdge(data, w, h, px, py);
      return sampleBrightness(data, w, h, px, py);
    }

    function getCellValue(data, w, h, x0, y0, x1, y1, mapMode) {
      const cx = Math.floor((x0 + x1) / 2), cy = Math.floor((y0 + y1) / 2);
      let val;
      if (mapMode === 'brightness') val = sampleCellBrightness(data, w, h, x0, y0, x1, y1);
      else if (mapMode === 'inverted') val = 1 - sampleCellBrightness(data, w, h, x0, y0, x1, y1);
      else if (mapMode === 'edges') val = sampleEdge(data, w, h, cx, cy);
      else if (mapMode === 'combined') {
        const lum = sampleCellBrightness(data, w, h, x0, y0, x1, y1);
        const edge = sampleEdge(data, w, h, cx, cy);
        val = Math.min(1, lum * 0.7 + edge * 0.5);
      }
      else if (mapMode === 'highcontrast') {
        val = sampleCellBrightness(data, w, h, x0, y0, x1, y1);
        val = val < 0.5 ? val * val * 2 : 1 - Math.pow(1 - val, 2) * 2;
        val = Math.max(0, Math.min(1, val));
      }
      else val = sampleCellBrightness(data, w, h, x0, y0, x1, y1);
      const contrastPct = parseInt(document.getElementById('contrast').value) || 100;
      return applyContrast(val, contrastPct);
    }

    function processCurrentFrame() {
      const w = video.videoWidth;
      const h = video.videoHeight;
      if (!w || !h) return false;
      const font = '10px ' + getComputedStyle(asciiOutput).fontFamily;
      const charMeasure = measureChar(font, 'M');
      const charAspect = charMeasure.width / (charMeasure.height || 10);
      const quality = parseInt(document.getElementById('quality').value) || 100;
      const density = (parseInt(document.getElementById('density').value) || 100) / 100;
      const q = quality / 100;
      const sampleSize = Math.max(4, Math.round(14 / q));
      const baseCols = Math.max(10, Math.floor(w / sampleSize));
      const baseRows = Math.max(5, Math.floor(h / (sampleSize * charAspect)));
      const charW = w / baseCols;
      const charH = h / baseRows;
      const verticalDensity = Math.max(0.5, density * 0.88);
      const stepX = charW / density;
      const stepY = charH / verticalDensity;
      const cols = Math.max(10, Math.floor(w / stepX));
      const rows = Math.max(5, Math.floor(h / stepY));
      if (fixedCols !== cols || fixedRows !== rows) {
        fixedCols = cols;
        fixedRows = rows;
      }
      const colorMode = document.getElementById('colorMode').value;
      const mapMode = document.getElementById('mapMode').value;
      const cellW = w / cols;
      const cellH = h / rows;
      ctx.canvas.width = w;
      ctx.canvas.height = h;
      ctx.drawImage(video, 0, 0);
      const imgData = ctx.getImageData(0, 0, w, h);
      const data = imgData.data;
      const charSet = CLASSIC_CHARSET;
      const len = Math.max(1, charSet.length);
      const monoColor = document.getElementById('colorPicker').value;
      const cells = [];

      if (colorMode === 'rgb') {
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const x0 = c * cellW, y0 = r * cellH, x1 = (c + 1) * cellW, y1 = (r + 1) * cellH;
            const { r: R, g: G, b: B, lum } = sampleCellRgb(data, w, h, x0, y0, x1, y1);
            const val = getCellValue(data, w, h, x0, y0, x1, y1, mapMode);
            const idx = Math.min(Math.floor(val * len), len - 1);
            if (colorChannel === 'r') cells.push({ ch: charSet[idx], r: R, g: 0, b: 0, lum });
            else if (colorChannel === 'g') cells.push({ ch: charSet[idx], r: 0, g: G, b: 0, lum });
            else if (colorChannel === 'b') cells.push({ ch: charSet[idx], r: 0, g: 0, b: B, lum });
            else cells.push({ ch: charSet[idx], r: R, g: G, b: B, lum });
          }
        }
      } else {
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            const x0 = c * cellW, y0 = r * cellH, x1 = (c + 1) * cellW, y1 = (r + 1) * cellH;
            const { lum } = sampleCellRgb(data, w, h, x0, y0, x1, y1);
            const val = getCellValue(data, w, h, x0, y0, x1, y1, mapMode);
            const idx = Math.min(Math.floor(val * len), len - 1);
            cells.push({ ch: charSet[idx], mono: monoColor, lum });
          }
        }
      }

      const depthPct = parseInt(document.getElementById('depth').value) || 80;
      const baseRgb = hexToRgb(monoColor);
      for (let i = 0; i < cells.length; i++) {
        const c = cells[i];
        if (c.lum !== undefined && depthPct > 0) {
          const rgb = colorMode === 'rgb'
            ? applyDepth({ r: c.r, g: c.g, b: c.b }, c.lum, depthPct)
            : applyDepth(baseRgb, c.lum, depthPct);
          c.r = rgb.r; c.g = rgb.g; c.b = rgb.b;
        } else if (colorMode === 'mono') {
          const rgb = applyDepth(baseRgb, c.lum ?? 0.5, depthPct);
          c.r = rgb.r; c.g = rgb.g; c.b = rgb.b;
        } else {
          c.r = Math.round(c.r); c.g = Math.round(c.g); c.b = Math.round(c.b);
        }
      }
      prevFrameData = lastFrameData;
      lastFrameData = { cols, rows, cells, colorMode, baseCols: baseCols || cols, baseRows: baseRows || rows };
      return true;
    }

    function frameToAscii() {
      if (video.readyState < 2) {
        rafId = requestAnimationFrame(frameToAscii);
        return;
      }
      if (video.paused) {
        if (processCurrentFrame()) {
          drawToOverlayCanvas();
          if (!hasSentFrameSignal) {
            window.parent?.postMessage({ type: 'ascii:frame' }, '*');
            hasSentFrameSignal = true;
          }
        }
        rafId = requestAnimationFrame(frameToAscii);
        return;
      }
      if (!processCurrentFrame()) {
        rafId = requestAnimationFrame(frameToAscii);
        return;
      }
      drawToOverlayCanvas();
      if (!hasSentFrameSignal) {
        window.parent?.postMessage({ type: 'ascii:frame' }, '*');
        hasSentFrameSignal = true;
      }
      rafId = requestAnimationFrame(frameToAscii);
    }

    video.onplay = () => {
      if (!rafId) frameToAscii();
    };
    video.onpause = () => {
      if (rafId) cancelAnimationFrame(rafId);
      rafId = null;
    };
    video.onloadedmetadata = () => {
      if (video.currentTime === 0) {
        try { video.currentTime = 0.001; } catch (_) {}
      }
    };
    video.oncanplay = () => {
      if (!rafId) frameToAscii();
    };

    new ResizeObserver(() => drawToOverlayCanvas()).observe(document.getElementById('mediaFrame'));
    document.getElementById('mode').dispatchEvent(new Event('change'));

    document.getElementById('recordBtn').onclick = async () => {
      if (video.readyState < 2 || !video.videoWidth) {
        alert('Load a video first');
        return;
      }
      if (typeof VideoEncoder === 'undefined') {
        alert('Your browser does not support WebCodecs. Use Chrome, Edge, or Safari 16.4+ for MP4 export.');
        return;
      }
      const btn = document.getElementById('recordBtn');
      const wasPlaying = !video.paused;
      const savedTime = video.currentTime;
      const wasLoop = video.loop;
      const cleanup = () => {
        video.loop = wasLoop;
        video.currentTime = savedTime;
        if (wasPlaying) video.play();
        btn.disabled = false;
        btn.textContent = 'Download MP4';
      };
      btn.disabled = true;
      btn.textContent = 'Processing...';
      video.pause();
      recordedChunks = [];
      prevFrameData = null;
      let encoder = null;
      try {
        const duration = video.duration;
        if (!duration || !isFinite(duration) || duration <= 0) {
          cleanup();
          alert('Could not read video duration.');
          return;
        }
        const speed = parseFloat(document.getElementById('speed').value) || 1;
        const outputFps = 30;
        const totalFrames = Math.ceil((duration / speed) * outputFps);
        if (totalFrames === 0) {
          cleanup();
          alert('Video is too short to export.');
          return;
        }
        const frameInterval = duration / totalFrames;
        const scale = parseInt(document.getElementById('resolution').value) || 2;
        const videoW = video.videoWidth;
        const videoH = video.videoHeight;
        const mediaFrame = document.getElementById('mediaFrame');
        const frameRect = mediaFrame.getBoundingClientRect();
        let targetW, targetH;
        if (videoW && videoH) {
          const s = Math.min(frameRect.width / videoW, frameRect.height / videoH);
          targetW = videoW * s;
          targetH = videoH * s;
        } else {
          targetW = frameRect.width;
          targetH = frameRect.height;
        }
        let w = Math.floor(targetW * scale) & ~1;
        let h = Math.floor(targetH * scale) & ~1;
        w = Math.max(2, w);
        h = Math.max(2, h);
        if (w * h > 921600) {
          const f = Math.sqrt(921600 / (w * h));
          w = Math.max(2, (Math.floor(w * f) & ~1));
          h = Math.max(2, (Math.floor(h * f) & ~1));
        }
        recordCanvas.width = w;
        recordCanvas.height = h;
        const bitrate = Math.min(5_000_000, Math.max(500_000, ((w * h) / (1920 * 1080)) * 2_000_000) | 0);
        const { Muxer, ArrayBufferTarget } = await import('https://esm.sh/mp4-muxer@3');
        const target = new ArrayBufferTarget();
        const muxer = new Muxer({ target, video: { codec: 'avc', width: w, height: h }, fastStart: 'in-memory' });
        encoder = new VideoEncoder({
          output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),
          error: (e) => { console.error('VideoEncoder error', e); }
        });
        encoder.configure({
          codec: 'avc1.42001f',
          width: w,
          height: h,
          bitrate,
          framerate: outputFps,
          hardwareAcceleration: 'prefer-hardware'
        });
        video.loop = false;
        const durationUs = 1e6 / outputFps;
        const seekMs = 120;
        let encodedCount = 0;
        for (let i = 0; i < totalFrames; i++) {
          if (encoder.state !== 'configured') break;
          video.currentTime = Math.min(i * frameInterval, duration - 0.001);
          await Promise.race([
            new Promise(r => { video.onseeked = () => r(); }),
            new Promise(r => setTimeout(r, seekMs))
          ]);
          while (encoder.encodeQueueSize > 8) await new Promise(r => requestAnimationFrame(r));
          await new Promise(r => requestAnimationFrame(r));
          if (video.readyState >= 2 && processCurrentFrame()) {
            drawToRecordCanvas();
            const frame = new VideoFrame(recordCanvas, { timestamp: i * durationUs, duration: durationUs });
            try {
              encoder.encode(frame, { keyFrame: i % 30 === 0 });
              encodedCount++;
            } finally {
              frame.close();
            }
          }
          if (i % 15 === 0 || i === totalFrames - 1) btn.textContent = `Frame ${i + 1}/${totalFrames} (${Math.round(100 * (i + 1) / totalFrames)}%)`;
        }
        if (encodedCount === 0) {
          if (encoder.state !== 'closed') encoder.close();
          cleanup();
          alert('No frames were encoded. Try a different video or browser.');
          return;
        }
        btn.textContent = 'Finalizing MP4...';
        await encoder.flush();
        if (encoder.state !== 'closed') encoder.close();
        muxer.finalize();
        if (!target.buffer || target.buffer.byteLength < 1000) {
          cleanup();
          alert('Export produced an invalid file.');
          return;
        }
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([target.buffer], { type: 'video/mp4' }));
        a.download = `ascii-video-${Date.now()}.mp4`;
        a.click();
        URL.revokeObjectURL(a.href);
      } catch (err) {
        if (encoder && encoder.state !== 'closed') encoder.close();
        cleanup();
        alert('Export failed: ' + (err?.message || String(err)));
        return;
      }
      cleanup();
    };

    document.getElementById('exportReactBtn').onclick = () => {
      const preset = {
        mode: document.getElementById('mode').value,
        speed: parseFloat(document.getElementById('speed').value) || 1,
        fontFamily: getComputedStyle(asciiOutput).fontFamily,
        colorMode: document.getElementById('colorMode').value,
        colorPicker: document.getElementById('colorPicker').value,
        mapMode: document.getElementById('mapMode').value,
        contrast: parseInt(document.getElementById('contrast').value) || 100,
        customChars: CLASSIC_CHARSET,
        quality: parseInt(document.getElementById('quality').value) || 100,
        density: parseInt(document.getElementById('density').value) || 100,
        fontSize: parseInt(document.getElementById('fontSize').value) || 100,
        resolution: parseInt(document.getElementById('resolution').value) || 2,
        depth: parseInt(document.getElementById('depth').value) || 80,
        smoothness: parseInt(document.getElementById('smoothness').value) || 0
      };
      const presetJson = JSON.stringify(preset, null, 2);
      const comp = `import { useEffect, useRef } from 'react';

const DEFAULT_PRESET = ${presetJson};

function luminance(R, G, B) { return (0.299 * R + 0.587 * G + 0.114 * B) / 255; }
function hexToRgb(hex) {
  const m = hex.match(/^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i);
  return m ? { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) } : { r: 0, g: 255, b: 0 };
}
function applyContrast(val, pct) { return pct === 100 ? val : Math.pow(Math.max(0, Math.min(1, val)), 100 / pct); }
function applyDepth(base, lum, pct) {
  if (pct === 0) return base;
  const t = pct / 100, b = 0.04 + 0.96 * lum, m = 1 - t + t * b;
  return { r: Math.round(base.r * m), g: Math.round(base.g * m), b: Math.round(base.b * m) };
}
function sampleCellRgb(data, w, h, x0, y0, x1, y1) {
  let r = 0, g = 0, b = 0, c = 0;
  const xs = Math.max(0, Math.floor(x0)), xe = Math.min(w, Math.ceil(x1));
  const ys = Math.max(0, Math.floor(y0)), ye = Math.min(h, Math.ceil(y1));
  for (let py = ys; py < ye; py++) for (let px = xs; px < xe; px++) {
    const i = (py * w + px) * 4; r += data[i]; g += data[i + 1]; b += data[i + 2]; c++;
  }
  if (c === 0) return { r: 0, g: 0, b: 0, lum: 0 };
  return { r: r / c, g: g / c, b: b / c, lum: luminance(r / c, g / c, b / c) };
}
function sampleCellBrightness(data, w, h, x0, y0, x1, y1) {
  let sum = 0, c = 0;
  const xs = Math.max(0, Math.floor(x0)), xe = Math.min(w, Math.ceil(x1));
  const ys = Math.max(0, Math.floor(y0)), ye = Math.min(h, Math.ceil(y1));
  for (let py = ys; py < ye; py++) for (let px = xs; px < xe; px++) {
    const i = (py * w + px) * 4; sum += luminance(data[i], data[i + 1], data[i + 2]); c++;
  }
  return c > 0 ? sum / c : 0;
}
function sampleBrightness(data, w, h, px, py) {
  const i = (Math.min(py, h - 1) * w + Math.min(px, w - 1)) * 4;
  return luminance(data[i], data[i + 1], data[i + 2]);
}
function sampleEdge(data, w, h, px, py) {
  const g = (x, y) => sampleBrightness(data, w, h, x, y);
  const gx = (-g(px - 1, py - 1) - 2 * g(px - 1, py) - g(px - 1, py + 1) + g(px + 1, py - 1) + 2 * g(px + 1, py) + g(px + 1, py + 1)) / 4;
  const gy = (-g(px - 1, py - 1) - 2 * g(px, py - 1) - g(px + 1, py - 1) + g(px - 1, py + 1) + 2 * g(px, py + 1) + g(px + 1, py + 1)) / 4;
  return Math.min(1, Math.sqrt(gx * gx + gy * gy) * 3);
}
function getCellValue(data, w, h, x0, y0, x1, y1, mapMode, contrastPct) {
  const cx = Math.floor((x0 + x1) / 2), cy = Math.floor((y0 + y1) / 2);
  let val;
  if (mapMode === 'brightness') val = sampleCellBrightness(data, w, h, x0, y0, x1, y1);
  else if (mapMode === 'inverted') val = 1 - sampleCellBrightness(data, w, h, x0, y0, x1, y1);
  else if (mapMode === 'edges') val = sampleEdge(data, w, h, cx, cy);
  else if (mapMode === 'combined') { const lum = sampleCellBrightness(data, w, h, x0, y0, x1, y1); const edge = sampleEdge(data, w, h, cx, cy); val = Math.min(1, lum * 0.7 + edge * 0.5); }
  else if (mapMode === 'highcontrast') { val = sampleCellBrightness(data, w, h, x0, y0, x1, y1); val = val < 0.5 ? val * val * 2 : 1 - Math.pow(1 - val, 2) * 2; val = Math.max(0, Math.min(1, val)); }
  else val = sampleCellBrightness(data, w, h, x0, y0, x1, y1);
  return applyContrast(val, contrastPct);
}
function lerpCell(prev, curr, blend) {
  if (!prev || prev.r === undefined) return curr;
  return { ...curr, r: Math.round((prev.r || 0) * blend + curr.r * (1 - blend)), g: Math.round((prev.g || 0) * blend + curr.g * (1 - blend)), b: Math.round((prev.b || 0) * blend + curr.b * (1 - blend)) };
}

export function AsciiVideo({ videoSrc, preset = DEFAULT_PRESET, className = '', style = {}, width, height, loop = true, muted = true, playbackRate }) {
  const containerRef = useRef(null);
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const sampleRef = useRef(null);
  const prevFrameRef = useRef(null);
  const rafRef = useRef();

  const p = { ...DEFAULT_PRESET, ...preset };

  useEffect(() => {
    const video = videoRef.current;
    const canvas = canvasRef.current;
    const sampleCanvas = sampleRef.current;
    const container = containerRef.current;
    if (!video || !canvas || !sampleCanvas || !container) return;
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const sampleCtx = sampleCanvas.getContext('2d', { willReadFrequently: true });
    if (!ctx || !sampleCtx) return;
    const charAspect = 0.6;
    const q = p.quality / 100;
    const density = p.density / 100;
    const sampleSize = Math.max(4, Math.round(14 / q));

    function processFrame() {
      const w = video.videoWidth, h = video.videoHeight;
      if (!w || !h) return;
      sampleCanvas.width = w; sampleCanvas.height = h;
      sampleCtx.drawImage(video, 0, 0);
      const data = sampleCtx.getImageData(0, 0, w, h).data;
      const baseCols = Math.max(10, Math.floor(w / sampleSize));
      const baseRows = Math.max(5, Math.floor(h / (sampleSize * charAspect)));
      const charW = w / baseCols, charH = h / baseRows;
      const verticalDensity = Math.max(0.5, density * 0.88);
      const stepX = charW / density, stepY = charH / verticalDensity;
      const cols = Math.max(10, Math.floor(w / stepX)), rows = Math.max(5, Math.floor(h / stepY));
      const cellW = w / cols, cellH = h / rows;
      const charSet = (p.customChars || "@#W$9876543210?!abc;:+=-,._~^*|/<>[]{}()");
      const len = Math.max(1, charSet.length);
      const monoRgb = hexToRgb(p.colorPicker);
      const cells = [];
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const x0 = c * cellW, y0 = r * cellH, x1 = (c + 1) * cellW, y1 = (r + 1) * cellH;
          const val = getCellValue(data, w, h, x0, y0, x1, y1, p.mapMode, p.contrast);
          const idx = Math.min(Math.floor(val * len), len - 1);
          const ch = charSet[idx];
          const { r: R, g: G, b: B, lum } = sampleCellRgb(data, w, h, x0, y0, x1, y1);
          let cell = p.colorMode === 'rgb' ? { ch, r: R, g: G, b: B } : { ch, ...applyDepth(monoRgb, lum, p.depth) };
          if (p.colorMode === 'rgb' && p.depth > 0) cell = { ...cell, ...applyDepth({ r: cell.r, g: cell.g, b: cell.b }, lum, p.depth) };
          const prev = prevFrameRef.current?.cells[cells.length];
          if (prev && p.smoothness > 0) cell = lerpCell(prev, cell, p.smoothness / 100);
          cells.push(cell);
        }
      }
      prevFrameRef.current = { cols, rows, cells };
      const rect = container.getBoundingClientRect();
      const scale = Math.min(rect.width / w, rect.height / h);
      const renderW = Math.floor(w * scale * p.resolution), renderH = Math.floor(h * scale * p.resolution);
      canvas.width = renderW; canvas.height = renderH;
      canvas.style.width = w * scale + 'px'; canvas.style.height = h * scale + 'px';
      ctx.imageSmoothingEnabled = false;
      const cellW2 = renderW / cols, cellH2 = renderH / rows;
      const baseCellH = renderH / Math.max(1, rows);
      const baseFontSize = Math.max(4, Math.min(96, Math.floor(baseCellH * 0.94)));
      const fontSizeScale = p.fontSize || 100;
      const fontSize = Math.max(4, Math.min(96, Math.round(baseFontSize * fontSizeScale / 100)));
      ctx.font = fontSize + 'px ' + p.fontFamily;
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      if (p.mode === 'overlay') ctx.drawImage(video, 0, 0, renderW, renderH);
      else { ctx.fillStyle = '#000'; ctx.fillRect(0, 0, renderW, renderH); }
      let i = 0;
      for (let r = 0; r < rows; r++) for (let c = 0; c < cols; c++) {
        const cell = cells[i++];
        ctx.fillStyle = 'rgb(' + cell.r + ',' + cell.g + ',' + cell.b + ')';
        ctx.fillText(cell.ch, (c + 0.5) * cellW2, (r + 0.5) * cellH2);
      }
    }
    function tick() { if (video.readyState >= 2) processFrame(); rafRef.current = requestAnimationFrame(tick); }
    video.playbackRate = playbackRate ?? p.speed;
    rafRef.current = requestAnimationFrame(tick);
    return () => { if (rafRef.current) cancelAnimationFrame(rafRef.current); };
  }, [videoSrc, preset, playbackRate]);

  return (
    <div ref={containerRef} className={className} style={{ position: 'relative', width: width || '100%', height: height || '100%', ...style }}>
      <video ref={videoRef} src={videoSrc} muted={muted} loop={loop} playsInline style={{ position: 'absolute', width: '100%', height: '100%', objectFit: 'contain' }} />
      <canvas ref={canvasRef} style={{ position: 'absolute', left: 0, top: 0, pointerEvents: 'none' }} />
      <canvas ref={sampleRef} style={{ position: 'absolute', left: -9999, width: 1, height: 1 }} />
    </div>
  );
}
`;
      const blob = new Blob([comp], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'AsciiVideo.tsx';
      a.click();
      URL.revokeObjectURL(url);
    };
  </script>
</body>
</html>
